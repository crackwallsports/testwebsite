#+TITLE: Common Lisp - 笔记整理 (草稿)
#+AUTHOR: Xt3
#+OPTIONS: html-postamble:nil html-style:nil tex:nil
#+HTML_DOCTYPE: html5
#+HTML_HEAD:<link href="/testwebsite/css/org.css" rel="stylesheet"></link>


* COMMENT Generate
#+BEGIN_SRC lisp
(twb::gen-with-frame "Common Lisp Note"
                #P"articles/common-lisp-note.html")
#+END_SRC

* 准备
- 实现
  - CCL
  - SBCL
- 编辑器 : Emacs
  - Slime
  - lispy


* 开始
Live 活着的
- 交互能力 实时修改 快速反馈
- REPL : 读 求值 打印 循环
  
** 自身
- 语法 : S-表达式
  - 原子 (列表以外的)
  - 列表 (括号括起来的)
- 求值
  - atom => self (自求值 : 返回自身)
    - Symbol => value  (: 符号引用对象)
      - t nil :keyword => self
  - list (根据第一个元素)
    - function 函数 : 参数从左到右先求值 再传入函数求值
    - special 特殊形式 : 各自特定的规则
      - 不求值 : quote
    - macro 宏 : 参数不求值
      
*** Comment 注释
#+BEGIN_SRC lisp
;;;; File header

;;; Paragraph
(defun foo (x)
  ;; Follow multiple lines
  (bar)
  (ted i)                             ; Current line
  (baz))

#| Multiple lines
    #|
       Nested
    |#
|#
#+END_SRC

*** Reader & Printer 读取器 和 打印器 :?:
*** Quote 引用
- Homoiconicity 同象性 : 程序 & 数据
- 引用 : quote (sugar: ')
  - 符号作为数据 : 'foo
  - 程序(列表)作为数据 : '(+ 1 2)
  - Ex.
    #+BEGIN_SRC lisp
;; (quote ...) == '(...)
'(x y z)                  ;-> (X Y Z)
(quote x)                 ;-> X
(list 'quote 1)           ;-> '1  ;== (quote 1)
(list 'quote 'y)          ;-> 'Y
    #+END_SRC
- 反引用
  - backquote (sugar: `)
    #+BEGIN_SRC lisp
`(x (+ 3 3) y)  ;-> (X (+ 3 3) Y)
`(x ,(+ 3 3) y) ;-> (X 6 Y)
`(x (x y z))    ;-> (X (X Y Z))
`(x ,@'(x y z)) ;-> (X X Y Z)
`(x . ,'(x y z)) ;-> (X X Y Z)
    #+END_SRC

*** Special 特殊操作符
- 25个
- 词法环境 : let let* setq progv
- 函数 : function labels flet
- 宏 : macrolet symbol-macrolet
- 控制流
  - if
  - progn
  - block return-from return
  - tagbody go
  - catch throw
  - unwind-protect
- 多值 : multiple-value-call multiple-value-prog1
- 求值 : quote eval-when load-time-value
  - load-time-value : 若编译则只求值一次
- 类型 : locally the
*** Type System 类型系统
- 动态类型 : 运行时检测 名字 可关联 任何类型的对象
- 强类型 : 所有的类型错误都会被检测
- Class 可作为 Type 使用 (相反不可) : 定义 class 时 会自动定义一个同名的 Type 
- 名字(变量)没有类型  只有值才有类型

操作
- Case : typecass ctypecase etypecase
- Determining : type-of
  #+BEGIN_SRC lisp
(type-of 'x)  ;-> SYMBOl
(type-of '(+ 1)) ;-> CONS
(type-of nil) ;-> NULL
   #+END_SRC
- Check : check-type typep
  #+BEGIN_SRC lisp
(defun my-sqrt (x)
  (check-type x (real 0)) 
  (sqrt x))  
(my-sqrt -9) ;; Error: TYPE-ERROR

(defun my-sqrt (list)
  (check-type (first list) (real 0) "a non-negative real number")
  (sqrt (first list)))
  #+END_SRC

**** Type Specifier 类型标识符 :?:
*** Symbol 符号
- 符号的内部结构
  - name     : symbol-name
  - package  : symbol-package := home package | nil(uninterned)
  - value    : symbol-value
  - function : symbol-function
  - plist    : symbol-plist
    #+BEGIN_SRC lisp
(setf (get 'a 'ss) 1)
(symbol-plist 'a) ;;-> (SS 1)
(get 'a 'ss) ;-> 1
    #+END_SRC
- 命名
  - 大小写不敏感 保持大小写使用"||"包围
  - 不能
    - 只有: 数字 或 "."
    - 含有: Whitespace [()"'`,:;\|]
  - 使用不被允许的字符
    - Escape : \
    - Surrounding : ||
      #+BEGIN_SRC lisp
|lisp 3|
| | 
|abc|      
      #+END_SRC
*** Name 名字
- 基于: 符号
- 约定
  - 全局变量 : *name*
  - 常量 : +name+
  - 特别低层的函数 : 前缀 %|%%
  - 分隔名字 : -
  - 谓词 : 后缀 p|-p
- 函数和变量 使用不同 名称空间
  #+BEGIN_SRC lisp
(defun fn () 2)
(defparameter fn 1)
fn ;-> 1
(fn) ;-> 2
#'fn ;-> #<Compiled-function FN #x3020033714EF>

(symbol-value 'fn) ;-> 1
(symbol-function 'fn) ;-> #<Compiled-function FN #x3020033714EF>
  #+END_SRC

*** Package
- 包 : 符号的集合 用于名称空间
- 创建 : make-package defpackage
  #+BEGIN_SRC lisp
;; (make-package name &key nicknames use)
(make-package :package-test) ;-> #<Package "PACKAGE-TEST">
(make-package #:package-test) ;-> #<Package "PACKAGE-TEST">
(make-package 'package-test) ;-> #<Package "PACKAGE-TEST">
(make-package "package-test") ;-> #<Package "package-test">
(make-package '|package-test|) ;-> #<Package "package-test">

(make-package :my-package :nicknames '(:myp "myp"))
(make-package "my-package" :use '(:cl))

;; (defpackage ...)
(defpackage :my-package
  (:nicknames :myp "my-pkg")
  (:use :cl)
  (:shadow #:car #:cdr)
  (:shadowing-import-from :cl #:cons)
  (:import-from :pkgname #:bye)
  (:intern #:hi)
  (:export #:egg #:milk))
  #+END_SRC
- 删除 : delete-package
  #+BEGIN_SRC lisp
(delete-package :my-pkg)
  #+END_SRC
- 改变当前包 : in-package 
  #+BEGIN_SRC lisp
(in-package :my-pkg)
    #+END_SRC
- 重命名 : rename-package
  #+BEGIN_SRC lisp
;; (rename-package :oldname :newname '(:nickname))
(make-package :temp :nicknames '(:tp))
(rename-package :temp :temps) ;->  #<PACKAGE "TEMPS">
(package-name :temp)          ;-> There is no package named "TEMP" .
(package-nicknames :temps) ;->  ()
    #+END_SRC
- Use | Import | Export 
  #+BEGIN_SRC lisp
;; use-package : inherit all external symbol
(use-package :cl)
(use-package :cl :temp) ;; in TEMP use CL
(unuse-package :cl)

;; import : add symbol to internal of package
(import 'cl:car (make-package :temp))

;; shadowing-import
(shadowing-import 'cl::car :temp) 

;; export | unexport
(export 'temp::temp-sym :temp)
(unexport 'temp::temp-sym :temp)
#+END_SRC
- Intern : intern unintern
  #+BEGIN_SRC lisp
;; intern : enter symbol named string into package
(intern "Never-Before") ;->  |Never-Before|, NIL
(intern "Never-Before") ;->  |Never-Before|, :INTERNAL 
(intern "NEVER-BEFORE" "KEYWORD") ;->  :NEVER-BEFORE, NIL
(intern "NEVER-BEFORE" "KEYWORD") ;->  :NEVER-BEFORE, :EXTERNAL
(intern "AAAA") ;-> AAAA
(intern "aaa") ;-> |aaa|

;; unintern
(unintern "Never-Before") ;-> T
(find-symbol "Never-Before") ;-> NIL, NIL 
    #+END_SRC
- 屏蔽符号 : shadow
  #+BEGIN_SRC lisp
;; 屏蔽在当前包
(shadow 'sym) 

;; 屏蔽其它包中导入的 
(shadow 'pkg:sym)

;; 在:pkg包中屏蔽符号
(shadow 'sym :pkg)  
  #+END_SRC
- 包信息 : *package* list-all-packages find-package package-[name nicknames]
  #+BEGIN_SRC lisp
;;; Packge
;; Name
(package-name :cl) ;-> "COMMON-LISP"
;; Nickname 
(package-nicknames :common-lisp) ;-> ("CL")

;; All registered package
(list-all-packages)
;; Current-pkg 
(print *package*)
;; find-package
(find-package :cl) ;-> #<PACKAGE "COMMON-LISP">
   #+END_SRC
- 包与包关系 : package-[use used-by]-lisp
  #+BEGIN_SRC lisp
;; Use | Used package
(make-package :new-pkg :use '(:my-pkg))
(package-use-list :new-pkg) ;-> (#<Package "MY-PKG">)
(package-used-by-list :my-pkg) ;-> (#<Package "NEW-PKG">)
  #+END_SRC
- 包内符号
  #+BEGIN_SRC lisp
;;; Symbol
;; (find-symbol string &optional package)
(find-symbol "CAR" :cl-user) ;-> CAR, :INHERITED
;; find-all-symbols : searche every registered package
(find-all-symbols '+) ;-> (:+ + XT3.OOP::+)
;; Symbol in package
(symbol-package 'car) ;-> #<Package "COMMON-LISP">
;;; package-shadowing-symbols
(package-shadowing-symbols (make-package :temp)) ;-> ()
  #+END_SRC
- 迭代包内符号 : loop do-[all external]-symbols
  #+BEGIN_SRC lisp
;;; List all Symbol in Package
;; loop
(loop for s
   being each external-symbol|symbol|present-symbol of :cl
   count s)

;; do-symbols
(do-symbols (s (find-package :cl-user))
  (print s))
;; do-external-symbols
(do-external-symbols (s (find-package :cl-user))
  (print s))
;; do-all-symbols : iterates on every registered package
(let ((lst ()))                                                     
  (do-all-symbols (s lst)
    (when (eq (find-package :temp) (symbol-package s))
      (push s lst)))
  lst)
      #+END_SRC


*** Assignment 赋值
- setf : (setf name|place value)
  #+BEGIN_SRC lisp
(setf *x* (list 1 2 3))
(let ((n 3))
  (setf n 33))

;; Place
(setf (car *x*) 9)
;; *x* = (9 2 3)

;; 多个赋值
(let ((a 1)
      (b 2))
  (setf a 5
        b a)
  (list a b))
;;-> (5 5)
  #+END_SRC
- setq psetq(平行) : (setq name value)
  #+BEGIN_SRC lisp
(let ((a 1) (b 2))
  (setq a 3 b (+ a 1))
  (list a b))
;;-> (3 4)

(let ((a 1) (b 2))
  (psetq a b b a)
  (list a b))
;;-> (2 1)
  #+END_SRC
- set : (set symbol value)
  #+BEGIN_SRC lisp
(set 'x 1)
x ;;-> 1

(let ((a 3))
  (set 'a 1)
  a)
;;-> 3
  #+END_SRC
- multiple-value-setq
  #+BEGIN_SRC lisp
(let (a b c)
  (multiple-value-setq (a b c) (values 1 2))
  (list a b c) ;-> (1 2 NIL)
  (multiple-value-setq (a b) (values 4 5 6))
  (list a b c) ;-> (4 5 NIL)
  )
  #+END_SRC
- rotatef shiftf  (修改宏 参数只求值一次)
  #+BEGIN_SRC lisp
(setf a 0)
(setf b 1)
(rotatef a b)
a ;-> 1
b ;-> 0

(shiftf a b 10)
a ;-> 0 
b ;-> 10
  #+END_SRC

**** Setf Place
- 定义 : (setf name) | defsetf | define-setf-expander
  #+BEGIN_SRC lisp
;;; (setf name) 
;; 定义 : (defun (setf name) (new-val obj))
;;-| Can #'(setf name)
;; 调用 : (setf (name obj) new-val)
  #+END_SRC

*** Macro 宏
- 定义 : defmacro
  #+BEGIN_SRC lisp
(defmacro name (parameter*)
  "Optional doc string"
  body-form*)

;; &body : 与&rest等价 但许多开发环境会根据其修改宏缩进
;; &whole
(defmacro tfun (&whole form &rest body) `(list ',form ,@body))
(tfun 1 2 3) ;-> ((TFUN 1 2 3) 1 2 3)

;; Destructuring parameter list 解构形参列表
(defmacro macro (vars &body body) ...)
(defmacro macro ((a b c) &body body) ...)
    #+END_SRC
- 展开 : macroexpand-1(一层) macroexpand
- !! 注意
  - 多重求值问题 
  - 变量定义顺序
  - 重名 (gensym)

*** Feature 特性
- 用于区分运行环境
#+BEGIN_SRC lisp
*features*

;; #+|- | #+|-(and|or|not ..)

;;; a in impl A, b in impl B
(cons #+a "more" #-b "little" x) 
;; in impl A ;-> (cons "more" x)
;; in impl B ;-> (cons "little" x)
#+END_SRC

*** Error :?:

*** Debug :?:
*** Help
- apropos
  #+BEGIN_SRC lisp
;; opt second argument : limit search in particular package
(apropos "MAP" :cl)
;;..-> MAPC, Def: FUNCTION
  #+END_SRC
- describe
  #+BEGIN_SRC lisp
(describe 'length)
;;-> Symbol: LENGTH
;;-> Function
;;-> EXTERNAL in package: #<Package "COMMON-LISP">
;;-> Print name: "LENGTH"
;;-> Value: #<Unbound>
;;-> Function: #<Compiled-function LENGTH #x34C39B6>
;;-> Arglist: (SEQUENCE)
;;-> Plist: (:ANSI-CL-URL "fun_length.html")

(describe "LENGTH")
;;-> "LENGTH"
;;-> Type: (SIMPLE-BASE-STRING 6)
;;-> Class: #<BUILT-IN-CLASS SIMPLE-BASE-STRING>
;;-> Length: 6
;;-> 0: #\L
;;-> 1: #\E
;;-> 2: #\N
;;-> 3: #\G
;;-> 4: #\T
;;-> 5: #\H

(describe 3)
;;-> Fixnum: 3
;;-> Scientific: 3.00E+0
;;-> Log base 2: 1.5849625
;;-> Binary: #b11
;;-> Octal: #o3
;;-> Decimal: 3.
;;-> Hex: #x3
;;-> Roman: III
;;-> Character: #\ETX
;;-> Abbreviated: 3
;;-> As time: 8:00:03 Monday, 1 January, 1900
;;-> MOST-POSITIVE-FIXNUM: 1152921504606846975.
;;-> ; No value
  #+END_SRC
- inspect : 交互型describe 
  #+BEGIN_SRC lisp
(defparameter *thing*
              (vector :lp (list 20 "Hotels") 1971))
(inspect *thing*)
;;-:
1 ;: go one level deeper
(list $ $$) ;: $ $$ $$$ work like * 
(setf (first $) 200)
:s 0 #\M  ;: :s setf
:q
  #+END_SRC
- documentation
  #+BEGIN_SRC lisp
(documentation 'length 'function)
;;-> "returns the number of elements in sequence."

(defun docstring ()
  "This is docstring."
  t)
(documentation 'docstring 'function)
;;-> "This is docstring."
  #+END_SRC
  - second argument
    - 'variable : defvar, defparameter, defconstant
    - 'function : defun, defmacro, special form
    - 'structure : defstruct
    - 'type : deftype
    - 'setf : defsetf
    - 'compiler-macro : define-compiler-macro
    - 'method-combination : define-method-combination
    - t : returned depends upon type of first argument.

** 表示 和 操作
- 表示
  - 数字 : 1 -1 3.14159 3/2 #b1001 #o777 #xAC53
    - 12345678901012345678902012345678903012345678901
  - 字符串 : "我们彼此看着对方" "Hello World"
    - 字符 : #\x #\云  (编码: ASCII Unicode UTF-8)
    - "Hello" == #(#\H #\e #\l #\l #\o)
  - 真值 : t nil
    - 非nil 都为真
  - 名字(变量) : 关联一个对象
    - 比起使用变量这个术语 我更喜欢用名字或标签
    - 变量和常量 : 可不可以修改 名字与对象的关联 (是否可以把名字用到别的对象上) 
    - 符号
  - 过程 : 函数
    - 匿名函数(深藏功与名) : lambda
    - 关联一个名字 : defun
    - 返回值
  - 控制流程 : 顺序 条件分支if cond 循环
  - 复杂对象 : list array hash-table structure class(CLOS)
- 操作
  - 数学计算 : + - * / sin
  - 等等

* 表示
** Number 数
*** Rational 有理数
- Literal
  #+BEGIN_SRC lisp
;;; Integer
123         ;-> 123
-123        ;-> -123
1.          ;-> 1
15511210043330985984000000 ; probably a bignum

#b100       ;-> 4
#o777       ;-> 511
#xD         ;-> 13
;; #nr : base 2~36
#36rABC     ;-> 13368 
  

;;; Ratio
3/7         ;-> 3/7
4/6         ;-> 2/3
6/3         ;-> 2
#b1010/1011 ;-> 10/11  
  #+END_SRC

  
**** Integer 整数
- 类型 : fixnum bignum
  #+BEGIN_SRC lisp
(typep 1 'fixnum) ;-> t
(typep (1+ most-positive-fixnum) 'bignum) ;-> t
  #+END_SRC
- 整数大小无限制 : 内部会自动在必要时分配存储 从而转换到大数表示
- fixnum范围
  #+BEGIN_SRC lisp
(list most-positive-fixnum
      most-negative-fixnum)
;; ( 1152921504606846975
;;  -1152921504606846976)

(expt 2 60) ;-> 1152921504606846976
(expt 2 61) ;-> 2305843009213693952
  #+END_SRC
  
**** Ratio 比值
- Rational canonicalization 规约化 : 6/3 -> 2, 12/6 -> 4/3
- GET : numerator denominator
  #+BEGIN_SRC lisp
(numerator 3/5) ;-> 3
(denominator 3/5) ;-> 5
  #+END_SRC

*** Float 浮点数
- 实现依赖 [CCL]
- 类型 (precisions, sizes) :  s(short) f(float) d(double) l(long)
- Literal
  #+BEGIN_SRC lisp
1.0      ;-> 1.0
1e0 1s0 1f0      ;-> 1.0
1d0      ;-> 1.0d0

;; float
0.123    ;-> 0.123
.123     ;-> 0.123
123e-3   ;-> 0.123
123E-3   ;-> 0.123
0.123e20 ;-> 1.23e+19
1.33232332329032 ;-> 1.3323233

;; doble
123d23   ;-> 1.23d+25
1.33232332329032d0 ;-> 1.33232332329032D0

2.0/3    ; Error: 2.0/3 被当作一个 symbol name
2/3.0    ;-> 0.6666667
  #+END_SRC
- 范围 (格式:m-s-f) : most-[positive|negative]-long-float
  #+BEGIN_SRC lisp
(list most-negative-short-float
      most-positive-short-float
      most-negative-single-float
      most-positive-single-float
      most-negative-double-float
      most-positive-double-float
      most-negative-long-float
      most-positive-long-float)
;; (-3.4028235E+38 3.4028235E+38
;;  -3.4028235E+38 3.4028235E+38
;;  -1.7976931348623157D+308 1.7976931348623157D+308
;;  -1.7976931348623157D+308 1.7976931348623157D+308)
  #+END_SRC
  
*** Complex 复数
- Literal
  #+BEGIN_SRC lisp
#c(2 1)       ;-> #c(2 1)
#c(2/3 3/4)   ;-> #c(2/3 3/4)

#c(2 1.0)     ;-> #c(2.0 1.0)
#c(2.0 1.0d0) ;-> #c(2.0d0 1.0d0)
#c(1/2 1.0)   ;-> #c(0.5 1.0)

;; complex canonicalization
#c(3 0)       ;-> 3  
#c(1/2 0)     ;-> 1/2
#c(3.0 0.0)   ;-> #c(3.0 0.0)
  #+END_SRC
- GET : realpart imgpart

** Character 字符
- Literal
  #+BEGIN_SRC lisp
#\x      ;-> #\x

;; #\char-name for no-printing (:imp-d)
;;-| Space, Newline, Tab, Page, Rubout, Linefeed, Return, Backspace  
#\Space ;-> #\ 

;; Unicode (实现依赖)
#\U4E91  ; [SBCL]
#\U+4E91 ; [CCL]
;;
#\云 ;-> #\U+4E91  
  #+END_SRC
- 转换 (实现依赖)
  - code-char char-code
  - char-name name-char
    #+BEGIN_SRC lisp
(char-name #\return) ;-> "Return"
(char-name #\U+0) ;-> "Null"
(char-name #\U+123) ;-> "Latin_Small_Letter_G_With_Cedilla"

(name-char "Return") ;-> #\Return
(name-char "Null") ;-> #\Null
(name-char "Latin_Small_Letter_G_With_Cedilla")
;;-> #\Latin_Small_Letter_G_With_Cedilla
    #+END_SRC
** String 字符串
- 表示基于 : Vector-Char : 字符向量
- 创建 : Literal | make-string | make-array(:e-t='character)
  #+BEGIN_SRC lisp
"String"
;; \ : 用于转义 "" \ 
"Str\"ing" ;-> "Str\"ing"
"Str\\ing" ;-> "Str\\ing"

;; 不支持插值语法 和 \n(换行)等转义语法
"Stri\ng"  ;-> "String" 

;; Make
(make-string 3 :initial-element #\c) ;->  "ccc"
(make-array 5 :fill-pointer 0 :adjustable :element-type 'character) ;-> ""
  #+END_SRC  
- 字面值是否可变 ? 实现依赖
  #+BEGIN_SRC lisp
(eq "abc" "abc") ;-> NIL
(setf s0 "abc")
(setf s1 "abc")
(setf (char s0 0) #\1)
(list s0 s1) ;; ("1bc" "abc")

(setf s0 "abc")
(setf s1 s0)
(setf (char s0 0) #\1)
(list s0 s1) ;; ("1bc" "1bc")
  #+END_SRC

*** GET
- 单个元素 : char Vec.schar Arr.aref Seq.elt
  #+BEGIN_SRC lisp
(char "abc" 1) ;-> #\b
(char "云" 0) ;-> #\U+4E91
  #+END_SRC
- 子字符串 : Seq.subseq
- 长度 : Seq.length
  #+BEGIN_SRC lisp
(length "1234567") ;-> 7
(length "一二三四五六七") ;-> 7
(length "ÄÖÜ1") ;-> 4
  #+END_SRC
*** Split & Concat & Join & Trim
- 分隔 Split : cl-ppcre:split
  #+BEGIN_SRC lisp
(split "" "hel lo") ;-> ("h" "e" "l" " " "l" "o")

(split "\\s+" "foo   bar baz frob")
;;-> ("foo" "bar" "baz" "frob")
(ppcre:split "(\\s+)" "foo   bar baz frob" :with-registers-p t)
;;-> ("foo" "   " "bar" " " "baz" " " "frob")

(split "(,)|(;)" "foo,bar;baz" :with-registers-p t)
;;-> ("foo" "," NIL "bar" NIL ";" "baz") ;; ("," nil == mach(,) nomach(;))
(split "(,)|(;)" "foo,bar;baz" :with-registers-p t :omit-unmatched-p t)
;;-> ("foo" "," "bar" ";" "baz")

(split ":" "a:b:c:d:e:f:g::") ;-> ("a" "b" "c" "d" "e" "f" "g")
(split ":" "a:b:c:d:e:f:g::" :limit 0)
;;-> ("a" "b" "c" "d" "e" "f" "g")
(split ":" "a:b:c:d:e:f:g::" :limit 2)
;;-> ("a" "b:c:d:e:f:g::")
(split ":" "a:b:c:d:e:f:g::" :limit 3)
;;-> ("a" "b" "c:d:e:f:g::") 
  #+END_SRC
- 连接 Concat : Imp.concat
  #+BEGIN_SRC lisp
(defun concat (&rest s)
  (apply #'concatenate 'string s))
  #+END_SRC
- 加入 Join : Imp.join
  #+BEGIN_SRC lisp
(defun join (strs &optional (separator " "))
  (reduce (lambda (acc next)
            (format nil "~a~a~a" acc separator next))
       strs))  
  #+END_SRC
- 修剪 Trim : string-trim-[left right]
  #+BEGIN_SRC lisp
(string-trim "abc" "abcaakaaakabcaaa") ;->  "kaaak"
(string-trim '(#\Space #\Tab #\Newline) " garbanzo beans") ;->  "garbanzo beans"
(string-trim " (*)" " ( *three (silly) words* ) ") ;->  "three (silly) words"

(string-left-trim " (*)" " ( *three (silly) words* ) ") ;->  "three (silly) words* ) "
  #+END_SRC

*** Search & Replace
- 匹配 : Seq.(find position) Seq.(search mismatch) cl-ppcre:(scan-[to-strings] all-matches-[as-strings])
  #+BEGIN_SRC lisp
;; 返回 项 或 NIL
(find #\a "foobarbaz") ;-> #\a

;; 返回 位置 或 NIL
(position #\a "foobarbaz") ;-> 4

;; 匹配的第一个位置
(search "bar" "foobarbaz") ;-> 3
(search "Bar" "foobarbaz" :test #'string=) ;-> NIL

;; 不匹配的第一个位置
(mismatch "foobarbaz" "foom")            ;-> 3
;; 不匹配的第一个位置索引+1
(mismatch "foobarbaz" "baz" :from-end t) ;-> 6

;; scan -> match:(start end) register-match:(start end)
(scan "(a)*b" "xaaabd") ;-> 1 ;-> 5 ;-> #(3) ;-> #(4)
(scan-to-strings "(([^b])*)b" "aaabd") ;-> "aaab" ;-> #("aaa" "a")

;; all-matches -> match:(start end)
(all-matches "a" "foo bar baz") ;-> (5 6 9 10)
(all-matches-as-strings "\\d" "bar 3 baz 5") ;-> ("3" "5")
  #+END_SRC
- 替代 : Seq.substitute cl-ppcre:regex-replace-[all]  (破坏 : Seq.replace Seq.fill)
  #+BEGIN_SRC lisp
(substitute #\c #\a "abababab") ;-> "cbcbcbcb"
(substitute #\c #\A "abababab" :test 'string=) ;-> "abababab"

(regex-replace "fo+" "foo bar" "frob")     ;-> "frob bar" ;-> T
;; 忽略大小写匹配
(regex-replace "(?i)fo+" "FOO bar" "frob") ;-> "frob bar" ;-> T
;; 保留目标字符串大小写样式
(regex-replace "(?i)fo+" "Foo bar" "frob" :preserve-case t)
;;-> "Frob bar" ;-> T
(regex-replace-all "(?i)fo+" "foo Fooo FOOOO bar" 
                   "frob" :preserve-case t)
;;-> "frob Frob FROB bar" ;-> T
  #+END_SRC
*** Compare
- 大小写敏感 : string[= /= < > <= >=]
- 不敏感 : string-[equal not-equal lessp greaterp not-greaterp not-lessp]
- 前缀 和 后缀 : Imp.(prefixp suffixp)
  #+BEGIN_SRC lisp
(defun prefixp (start s &key (test #'string=))
  (let ((m (mismatch start s :test test)))
    (or (null m) (= m (length start)))))


(prefixp "foo" "foobarbaz" ) ;-> T
(prefixp "foo" "foo" ) ;-> T
(prefixp "foo" "barbaz" ) ;-> NIL

(defun suffixp (end s &key (test #'string=))
  (case (mismatch end s :from-end t :test test)
    ((0 nil) t)
    (t nil)))

(suffixp "baz" "foobaz" ) ;-> T

  #+END_SRC
*** Regex
- Lib:cl-ppcre
*** Coding
- Lib:[[https://github.com/cl-babel/babel][babel]]

*** Other
- string-[upcase downcase capitalize]
  #+BEGIN_SRC lisp
(string-upcase "abcde") ;->  "ABCDE"
(string-downcase "ABCDE") ;->  "abcde"
(string-capitalize "hello Good MORING") ;-> "Hello Good Moring"
(string-capitalize 'kludgy-hash-search) ;->  "Kludgy-Hash-Search"
(string-capitalize "DON'T!") ;->  "Don'T!" ;: not "Don't!"  
  #+END_SRC
* 基础
** 变量 和 常量
Variable 变量
- Global (Dynamic) : defparameter defvar  (命名约定: ~*name*~)
  #+BEGIN_SRC lisp
;;; defparameter
(defparameter *foo* 5)
(defparameter *foo* (+ 1 2))            ; *foo* == 3

;;; defvar
(defvar *bar* 5) ; *bar* = 5
;; 重定义不改变之前定义时的值
(defvar *bar* 6) ; *bar* == 5
;; 定义时可以不设置值
(defvar *bar*) ; *bar* == Unbound
    #+END_SRC      
- Local : let let*(可引用变量列表中早先引入的变量)
  #+BEGIN_SRC lisp
;; let
(let ((a 5) 􏰅
      (b 6))
  (+ a b))
;;-> 11

;; let*
(let* ((a 5)
       (b (+ a 2)))
  b)
;;-> 7
      #+END_SRC

Constant 常量
- defconstant (命名约定: ~+name+~)
  #+BEGIN_SRC lisp
(defconstant +name+ initial-value-form (doucmentation-string))  
  #+END_SRC


Dynamic (Special) Variable  (!!! 注意命名)
- all global variable are dynamic variable  
- Lexical scope & Dynamic extent variable 词法范围 和 动态作用域 变量
  #+BEGIN_SRC lisp
;; Lexical scope variable
(let ((x 3))
  (defun test () x))
(test)                ;-> 3
(let ((x 5)) (test))  ;-> 3

;; Dynamic extent variable
(defvar *special* 3)
(defun test () *special*)
(test) ;-> 3
(let ((*special* 5)) (test)) ;-> 5


;; !!! 注意命名 : 否则难以分清 可导致使用错误
(defparameter x 3)

(defun test () x)
(test) ;-> 3
(let ((x 0)) (test))  ;-> 0

(let ((x 1))
  (defun test () x))
(test) ;-> 3
(let ((x 0)) (test)) ;-> 0
    #+END_SRC
- Special: (declare (special ..))
  #+BEGIN_SRC lisp
(let ((y 1))
  (defun test () y))
(test) ;-> 1
(let ((y 1))
  (defun test ()
    (declare (special y))
    y))
(test)  ;-> Error: Unbound y
(progn (defparameter y 3)
       (test))
;;-> 3
  #+END_SRC

** 函数
- Lambda : 匿名函数
  #+BEGIN_SRC lisp
(lambda (n) (/ n 2))                   
;;-> #<Anonymous Function #x302000DB47EF>

;; Call
(funcall #'(lambda (x y) (+ x y)) 2 3) ;-> 5
((lambda (x y) (+ x y)) 2 3)           ;-> 5
((lambda () 42))                       ;-> 42
  #+END_SRC
- Name 命名
  - Global: defun
    #+BEGIN_SRC lisp
(defun name (arguments)
  "Optional document string"
  body-form)

(defun six () (+ 3 3))
(six) ;-> 6
    #+END_SRC
  - Local: flet labels(call another|recursion)
    #+BEGIN_SRC lisp
(flet ((f (n)
         (+ n 10))
       (g (n)
         (- n 3)))
  (g (f 5)))
;;-> 12

(labels ((a (n)
           (+ n 5))
         (b (n)
           (+ (a n) 6)))
  (b 10))
;;-> 21
    #+END_SRC
- Function Object: function (sugar:#')
  #+BEGIN_SRC lisp
;; 引用 符号命名的函数 (通常为 defun全局定义的)
(function car) ;-> #<Compiled-function CAR #x3000000FC18F>
#'car          ;-> #<Compiled-function CAR #x3000000FC18F>
  #+END_SRC
- 函数 既可以作为 定义抽象的方式 来产生抽象 也可以 作为一个抽象来使用
  - Higher-Order (first-class fun) : as paramater or return-value

*** Call
- apply | funcall
  #+BEGIN_SRC lisp
;; (最后一个参数需要是一个列表)
(apply (function car) '((x y))) ;-> X
(apply #'+ '(1 2 3 4 8))        ;-> 18
(apply #'+ 1 2 '(3))            ;-> 6

(funcall #'+ 1 3 5)    ;-> 9
(funcall #'car '(x y)) ;-> X
  #+END_SRC
- 局部函数的调用问题 : 先 局部  若使用 符号 而不是 #' 则 全局
  #+BEGIN_SRC lisp
(defun foo (x) (+ x 42))
(foo 0) ;-> 42
(funcall 'foo 0)                        ;-> 42
(funcall #'foo 0) ;-> 42

(flet ((foo (x) (1+ x)))
  (list (foo 0)                         ; Local
        (funcall 'foo 0)                ; Global
        (funcall #'foo 0)               ; Local
        ))
;;-> (1 42 1)
  #+END_SRC
*** Paramater list
- &optional 可选
  #+BEGIN_SRC lisp
;;; Optional
(defun foo (a b &optional c d) (list a b c d))
(foo 1 2)     ;-> (1 2 NIL NIL) 
(foo 1 2 3)   ;-> (1 2 3 NIL)
(foo 1 2 3 4) ;-> (1 2 3 4)  
  #+END_SRC
- &key 关键字
  #+BEGIN_SRC lisp
;;; Keyword 
(defun foo (&key a b (c 3)) (list a b c))
(foo)                ;-> (NIL NIL 3)
(foo :b 1)           ;-> (NIL 1 3)
(foo :a 1 :b 2 :c 3) ;-> (1 2 3)

;; 区分外部和内部调用名
(defun foo (&key ((:apple a)) ((:box b) 0)) (list a b))
(foo :apple 1 :box 2)  

;; 关键字名 可不为 关键字
(defun baz (&key ((foo bar) 42))
           (list bar))
(baz 'foo 23) ;-> (23)
  #+END_SRC
- Default value 默认值
  #+BEGIN_SRC lisp
;;; Default Value
(defun foo (a &optional (b 10)) (list a b))
(foo 1 2) ;-> (1 2)
(foo 1) ;-> (1 10)

;; value 可以是任何 lisp 表达式

;; 可依赖前面的参数
(defun foo (a &optional (b a)) (list a b))
(foo 1 2) ;-> (1 2)
(foo 1) ;-> (1 1)
  #+END_SRC
- supplied-p : 用于判断是否提供了实参
  #+BEGIN_SRC lisp
;;; supplied-p
(defun foo (a &optional (c 3 c-supplied-p)) 
  (list a c c-supplied-p))
(foo 1)   ;-> (1 3 NIL)
(foo 1 3) ;-> (1 3 T)  
  #+END_SRC
- &rest
  #+BEGIN_SRC lisp
;;; rest 
(defun my+ (&rest nums)
  (apply #'+ nums))  
  #+END_SRC
- &aux : define auxiliary local variables
  #+BEGIN_SRC lisp
;;; auxiliary
(defun average (&rest args
                &aux (len (length args)))
  (/ (reduce #'+ args) len 1.0))
(average 1 2 3) ;-> 2.0
  #+END_SRC
- &allow-other-keys : 允许未定义的关键字参数 并收集于此

参数数量上限  
- call-arguments-limit
- lambda-parameters-limit

组合使用问题
- Order: required &optional &rest &key
  - &rest and &key
    #+BEGIN_SRC lisp
  ;;; &rest + &key : 只能使用key
(defun foo (&rest rest &key a b c) (list rest a b c))
(foo :a 1 :b 2 :c 3) ;-> ((:A 1 :B 2 :C 3) 1 2 3)
(foo :a 1) ;-> ((:A 1) 1 NIL NIL)
(foo 1 2) ;-> Error
(foo 1 2 :a 1) ;-> Error
(foo :a 2 1 2) ;-> Error
    #+END_SRC
- Avoid
  - &optional + &key
    #+BEGIN_SRC lisp
(defun foo (x &optional y &key z) (list x y z))
(foo 1 2 :z 3) ;-> (1 2 3)
(foo 1)        ;-> (1 nil nil) 
(foo 1 :z 3)   ;-> Error: Incorrect keyword arguments in (3) .
(foo 1 :z :z 3) ;-> (1 :Z 3)
    #+END_SRC
*** Return Value
- 返回值 Return value : 默认返回最后一个表达式的值
- 返回多值 Return Multi-Values : values values-list
  #+BEGIN_SRC lisp
;;; Return Multi-Values
(values 'a nil (+ 1 2));;-> a ;-> nil ;-> 3
;; 列表作为参数
(values-list '(1 2))
;;-> 1 ;-> 2

;; 返回值 传递
((lambda () 
   ((lambda () (values 1 2))))) ;;-> 1 ;-> 2
;; 多返回值作为参数 只有第一个被使用
((lambda (x) x)
  (values 1 2)) ;-> 1

;; 若不需要使用返回值
((lambda () (format t "~a" 1)))
;;-> 1 ;-> NIL
((lambda ()
   (format t "~a" 1)
   (values)))
;;-> 1 ;-> ; No value

;; (values) 不是 不返回值
(+) ;->0
(+ (values)) ; Error: The value NIL is not of the expected type NUMBER.
(null (values)) ;-> T
  #+END_SRC
- 处理多返回值
  - 多值绑定 : multipel-value-bind
    #+BEGIN_SRC lisp
(multiple-value-bind (a b) (values 2 3)
  (* a b))   ;-> 6
(multiple-value-bind (a b) (values 2 3 2)
  (* a b)) ;-> 6
(multiple-value-bind (a b c) (values 2 3)
  c)       ;-> nil
    #+END_SRC
  - 多值作为函数参数 : multiple-value-call
    #+BEGIN_SRC lisp
(funcall #'+ (values 1 2 3)) ;->1
(multiple-value-call #'+ (values 1 2 3)) ;-> 6

(funcall #'+ (values 1 2 3) (values 4 5 6)) ;-> 5
(multiple-value-call #'+ (values 1 2 3) (values 4 5 6)) ;-> 21
    #+END_SRC
  - 多值->列表 : multiple-value-list
    #+BEGIN_SRC lisp
(multiple-value-list (values 'a 'b 'c)) ;-> (A B C)
    #+END_SRC

*** Closures
- 闭包 Closures : 捕捉创建时的环境信息 : 捕获的是变量 不是值
  #+BEGIN_SRC lisp
(setf fn (let ((i 3)) #'(lambda (x) (+ x i))))
(funcall *fn*) ;-> 1
(funcall *fn*) ;-> 2
(funcall *fn*) ;-> 3

(let ((count 0))
  (list
   #'(lambda () (incf count))
   #'(lambda () (decf count))
   #'(lambda () count)))
  #+END_SRC


** 控制流

* 概念
** Scope & Extent 作用域 和 生命周期
- Scope (space) & Extent (time) : Visibility & Lifetime
  - lexical 词法
  - dynamic 动态
- Shadowing
  - 同名 : 后者可能屏蔽前者

