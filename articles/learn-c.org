#+TITLE: 学习 C 语言 - 笔记整理 (草稿)
#+AUTHOR: Xt3
#+OPTIONS: html-postamble:nil html-style:nil tex:nil
#+HTML_DOCTYPE: html5
#+HTML_HEAD:<link href="/testwebsite/css/org.css" rel="stylesheet"></link>

#+version: 0.1


* COMMENT Generate
#+BEGIN_SRC lisp
(gen-with-frame "Learn C"
                #P"articles/learn-c.html")
#+END_SRC

* 开始前
** 我们要做什么?
- 将 脑子里想的东西 和 解决问题的方法 翻译成 程序 
- 程序 ~?:~ 计算机可以运行的 机器指令 (二进制代码 类似100000111100000100000001)
  - 我们直接写机器指令 ~?:~ bang... 脑袋炸了
  - 使用对应的 汇编指令 (addl $1, %ecx) ~?:~ 好一点 但还是不要
  - 自然语言 ~?:~ 喜欢 爱死了 ~!:~ 目前还不可能达到
  - 类似自然语言(高级语言) 限定的少量的词汇和语法 ~?:~ OK
- 三个问题
  - ? 用什么写程序
    - IDE (集成开发环境)
    - Editor (编辑器)
  - ? 怎么翻译 (高级语言 -> 机器指令)
    - 翻译(编译 或 解释) 
      - 编译器
      - 编译流程自动化
  - ? 如何运行
    - 运行
    - 输入 输出
- 脑子里的东西 和 解决问题的方法 怎么用 编程语言 写出来(表示) ?
  - 把 所想的东西 转换成 计算(算法, 步骤, 菜谱)
  - How?
- 计算机技术 基础知识 等等 (不在此笔记中啰嗦)
- 这里不关心 底层(计算机具体实现) 把它抽象掉(仅仅使用一些词语来代表)

** 准备
- 开发环境
  - 编辑器或IDE : Emacs or Xcode
  - 编译器 : gcc or clang
  - 编译流程自动化 : make, Makefile
- 流程示范: [OS:MacOS]
  - 打开 终端(Terminal)
  - 准备工作
    #+BEGIN_SRC shell :dir ~/
mkdir test # 建立 项目目录
cd test # 进入 项目目录
touch code.c # 新建 源文件
    #+END_SRC
  - 用编辑器 打开源文件 写代码
    #+BEGIN_SRC C
/* code.c */

#include <stdio.h>
int main(){
  printf("hello world");
}
    #+END_SRC
  - 编译 和 运行
    #+BEGIN_SRC shell :dir ~/test
cc code.c -o code
./code
    #+END_SRC
* 开始

** 第一步
- ? 我想让程序 输出 一些文字
  - 文字 怎么表达 ~?:~ 用 字符串
    #+BEGIN_SRC C
"字符串"
    #+END_SRC
  - 输出 ~?:~ 输出函数 这里使用puts函数
    #+BEGIN_SRC C
puts("字符串");
    #+END_SRC
    - ~!:~ puts不是我们定义的 需要导入头文件 (放在开头)
      #+BEGIN_SRC C
#include <stdio.h>
      #+END_SRC
  - 写在哪 ~?:~ main函数里 main()是程序执行的起点 这是约定
    #+BEGIN_SRC C
#include <stdio.h>

int main(){
  puts("字符串");
  
  return 0;
}    
    #+END_SRC
** 稍息
基础 就像是一块块不同的积木 我们要做的就是 把它们组合成 我们所希望的样子

一块积木是积木 两块积木组和起来也可被当作一个积木
给每块不同积木 或 组合后的积木 一个名字 就可以被方便的重复使用
我们编程就是 从符合规则的组合中 找到 能够解决待定问题的 一种最优的路径

已经准备好的积木 它们长啥样 怎么使用:
- 数字 : 整数 浮点数
- 简单的数学计算过程 : 四则运算符
- 名字 : 变量 指针
- 组合
  - 过程(按执行顺序) 
    - 顺序 : 一块接一块
    - 分支 : 每一块积木 可以和其它积木进行组合 产生的每一种符合规则的可能 就只一条分支
    - 循环 : 重复积木
    - 跳转 (很少用) : 往回等同于循环 往后就像是选择了不同的分支
  - 聚合 : 数组 结构 共用 枚举
- 封装过程(把组合起来的积木 给个名字 打包起来) : 函数 参数


** 第二步
- ? 输入温度(华氏 或 摄氏) -转换- 输出结果
  - 把问题分解为更小的部分 可以理解 甚至是可以直接求解 一个个解决 最后组合在一起
  - 分成三部分: 输入 转换 输出 
    - 输入 ~?:~ 从终端 形如: 30C
    - 转换 ~?:~ 公式: C = (5/9)(F-32) 和 F = (9C)/5+32
    - 输出 ~?:~ 到终端 形如: 30C 是 86F
  - 继续 (程序名为: C52F)
    - 输入 ~?:~ 从终端 形如: 30C
      - 从终端 ~?:~ 程序执行时
        #+BEGIN_SRC shell
C52F 30C        
        #+END_SRC
      - 程序内部如何处理 ~?:~ 运行程序提供的参数 将作为参数交给 main函数
        #+BEGIN_SRC c
// int argc, char *argv[]  : 参数个数 和 存储参数的数组
int main(int argc, char *argv[]){
  return 0;
}
        #+END_SRC
      - 处理参数
        #+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]){
  // 检查参数
  if(argc == 1){
    printf("请重新运行 并提供需要转换的温度(形如 30C 或 89F)\n");
    return 1;
  }
  // 获得参数
  char* tempStr = argv[1];
  // 转换参数 ?: 因为参数是字符串 为了计算 需要转换为 浮点数
  int loct = strlen(tempStr) - 1;
  char type = tempStr[loct];
  tempStr[loct] = '\0';
  double temp = atof(tempStr);
  
  return 0;
  
}
        #+END_SRC
    - 转换 ~?:~ 
      - 公式: C = (5/9)*(F-32) 和 F = (9C)*/5+32
        #+BEGIN_SRC c
// C = (5/9)*(F-32)
C = (5.0/9)*(F-32);
// F = (9*C)/5+32
F = (9*C)/5+32;
        #+END_SRC
      - 分发温度
        #+BEGIN_SRC c
switch (type) {
  case 'F': 
    // C =
    break;
  case 'C': 
    // F =
    break;
  default:
    printf("请重新运行 并提供需要转换的温度(形如 30C 或 89F)\n");
    return 1;
  }        
        #+END_SRC
      - 结合
        #+BEGIN_SRC c
char cvType = ' ';
switch (type) {
 case 'F':
   cvTemp = (5.0/9)*(temp-32);
   cvType = 'C';
   break;
 case 'C':
   cvTemp = (9*temp)/5+32;
   cvType = 'F';
   break;
 default:
   printf("请重新运行 并提供需要转换的温度(形如 30C 或 89F)\n");
   return 1;
 }
        #+END_SRC
    - 输出 ~?:~ 到终端 形如: 30C = 86F
      #+BEGIN_SRC c
printf("%s%c = %f%c\n", inTemp, intype, cvTemp, cvType);
      #+END_SRC
  - 完成
    #+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]){
  // 检查参数
  if(argc == 1){
    printf("请重新运行 并提供需要转换的温度(形如 30C 或 89F)\n");
    return 1;
  }
  // 获得参数
  char* tempStr = argv[1];
  // 转换参数 ?: 因为参数是字符串 为了计算 需要转换为 浮点数
  int loct = strlen(tempStr) - 1;
  char type = tempStr[loct];
  tempStr[loct] = '\0';
  double temp = atof(tempStr);

  // C = (5/9)(F-32) 和 F = (9C)/5+32
  double cvTemp = 0;
  char cvType = ' ';
  switch (type) {
  case 'F':
    cvTemp = (5.0/9)*(temp-32);
    cvType = 'C';
    break;
  case 'C':
    cvTemp = (9*temp)/5+32;
    cvType = 'F';
    break;
  default:
    printf("请重新运行 并提供需要转换的温度(形如 30C 或 89F)\n");
    return 1;
  }
  printf("%d%c = %f%c\n", (int)temp, type, cvTemp, cvType);
  return 0;

}
    #+END_SRC


!!! 干脆做视频 动态的表示 会更好 写出来太麻烦了 

* 基础
** 类型
** 数
- 整数
  #+BEGIN_SRC C
123
-789

// 进制表示法
31 // 十进制
025 // 八进制 0开头
0x19 // 十六进制 0x开头
  #+END_SRC
- 浮点数(小数)
  #+BEGIN_SRC C
123.3
.3, 3. // 省略部分
1.2e2, 1.2e-2 // 科学计数法
  #+END_SRC
** 字符
- 字符
- 内部表示 : 整数
  - ASCII编码 ?
    - 编码 ?
- 特殊字符(转义)

** 数组
** 指针
** 字符串
- 字符串
- 如何表示 ~?:~ 字符数组 或 字符指针
  #+BEGIN_SRC C
char str[] = {'\a', '\b', '\c', '\0'};
char* str = "abc"; 
  #+END_SRC
** 函数
- 把 部分程序 封装起来 并 给一个名字 (这个也叫: 定义) 方便重复使用
- 定义
- 调用
- 返回值
** IO
*** 标准输入输出
*** 文件
** 控制流程
- 顺序 分支 循环(递归)
** 结构 共用 枚举
** 动态内存分配
** 概念
- 头文件
  - 导入
- 字面量
- 作用域 生命周期
- 变量


* COMMENT Test
